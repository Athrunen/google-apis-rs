// DO NOT EDIT !
// This file was generated automatically from 'src/mako/api/lib.rs.in.mako'
// DO NOT EDIT !

#[cfg(feature = "nightly")]
#[macro_use]
extern crate serde_derive;

extern crate hyper;
extern crate serde;
extern crate serde_json;
extern crate yup_oauth2 as oauth2;
extern crate mime;
extern crate url;

mod cmn;

use std::collections::HashMap;
use std::cell::RefCell;
use std::borrow::BorrowMut;
use std::default::Default;
use std::collections::BTreeMap;
use serde_json as json;
use std::io;
use std::fs;
use std::thread::sleep;
use std::time::Duration;

pub use cmn::{MultiPartReader, ToParts, MethodInfo, Result, Error, CallBuilder, Hub, ReadSeek, Part,
              ResponseResult, RequestValue, NestedType, Delegate, DefaultDelegate, MethodsBuilder,
              Resource, ErrorResponse, remove_json_null_values};


// ##############
// UTILITIES ###
// ############




// ########
// HUB ###
// ######

/// Central instance to access all CivicInfo related resource activities
///
/// # Examples
///
/// Instantiate a new hub
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_civicinfo2 as civicinfo2;
/// use civicinfo2::VoterInfoRequest;
/// use civicinfo2::{Result, Error};
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use civicinfo2::CivicInfo;
/// 
/// // Get an ApplicationSecret instance by some means. It contains the `client_id` and 
/// // `client_secret`, among other things.
/// let secret: ApplicationSecret = Default::default();
/// // Instantiate the authenticator. It will choose a suitable authentication flow for you, 
/// // unless you replace  `None` with the desired Flow.
/// // Provide your own `AuthenticatorDelegate` to adjust the way it operates and get feedback about 
/// // what's going on. You probably want to bring in your own `TokenStorage` to persist tokens and
/// // retrieve them from storage.
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::new(),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = VoterInfoRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.elections().voter_info_query(req, "address")
///              .return_all_available_data(true)
///              .official_only(false)
///              .election_id("accusam")
///              .doit();
/// 
/// match result {
///     Err(e) => match e {
///         // The Error enum provides details about what exactly happened.
///         // You can also just use its `Debug`, `Display` or `Error` traits
///          Error::HttpError(_)
///         |Error::MissingAPIKey
///         |Error::MissingToken(_)
///         |Error::Cancelled
///         |Error::UploadSizeLimitExceeded(_, _)
///         |Error::Failure(_)
///         |Error::BadRequest(_)
///         |Error::FieldClash(_)
///         |Error::JsonDecodeError(_, _) => println!("{}", e),
///     },
///     Ok(res) => println!("Success: {:?}", res),
/// }
/// # }
/// ```
pub struct CivicInfo<C, A> {
    client: RefCell<C>,
    auth: RefCell<A>,
    _user_agent: String,
}

impl<'a, C, A> Hub for CivicInfo<C, A> {}

impl<'a, C, A> CivicInfo<C, A>
    where  C: BorrowMut<hyper::Client>, A: oauth2::GetToken {

    pub fn new(client: C, authenticator: A) -> CivicInfo<C, A> {
        CivicInfo {
            client: RefCell::new(client),
            auth: RefCell::new(authenticator),
            _user_agent: "google-api-rust-client/1.0.0".to_string(),
        }
    }

    pub fn divisions(&'a self) -> DivisionMethods<'a, C, A> {
        DivisionMethods { hub: &self }
    }
    pub fn elections(&'a self) -> ElectionMethods<'a, C, A> {
        ElectionMethods { hub: &self }
    }
    pub fn representatives(&'a self) -> RepresentativeMethods<'a, C, A> {
        RepresentativeMethods { hub: &self }
    }

    /// Set the user-agent header field to use in all requests to the server.
    /// It defaults to `google-api-rust-client/1.0.0`.
    ///
    /// Returns the previously set user-agent.
    pub fn user_agent(&mut self, agent_name: String) -> String {
        let prev = self._user_agent.clone();
        self._user_agent = agent_name;
        prev
    }
}


// ############
// SCHEMAS ###
// ##########
/// A search request for political geographies.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [search divisions](struct.DivisionSearchCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct DivisionSearchRequest {
    /// no description provided
    #[serde(rename="contextParams")]
    pub context_params: Option<ContextParams>,
}

impl RequestValue for DivisionSearchRequest {}


/// Describes information about a regional election administrative area.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct AdministrationRegion {
    /// The election administration body for this area.
    #[serde(rename="electionAdministrationBody")]
    pub election_administration_body: Option<AdministrativeBody>,
    /// The city or county that provides election information for this voter. This object can have the same elements as state.
    pub local_jurisdiction: Option<Option<Box<AdministrationRegion>>>,
    /// An ID for this object. IDs may change in future requests and should not be cached. Access to this field requires special access that can be requested from the Request more link on the Quotas page.
    pub id: Option<String>,
    /// The name of the jurisdiction.
    pub name: Option<String>,
    /// A list of sources for this area. If multiple sources are listed the data has been aggregated from those sources.
    pub sources: Option<Vec<Source>>,
}

impl Part for AdministrationRegion {}


/// Information about a person holding an elected office.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Official {
    /// The official's name.
    pub name: Option<String>,
    /// A URL for a photo of the official.
    #[serde(rename="photoUrl")]
    pub photo_url: Option<String>,
    /// The official's public contact phone numbers.
    pub phones: Option<Vec<String>>,
    /// A list of known (social) media channels for this official.
    pub channels: Option<Vec<Channel>>,
    /// The official's public website URLs.
    pub urls: Option<Vec<String>>,
    /// Addresses at which to contact the official.
    pub address: Option<Vec<SimpleAddressType>>,
    /// The full name of the party the official belongs to.
    pub party: Option<String>,
    /// The direct email addresses for the official.
    pub emails: Option<Vec<String>>,
}

impl Part for Official {}


/// Describes the geographic scope of a contest.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ElectoralDistrict {
    /// The geographic scope of this district. If unspecified the district's geography is not known. One of: national, statewide, congressional, stateUpper, stateLower, countywide, judicial, schoolBoard, cityWide, township, countyCouncil, cityCouncil, ward, special
    pub scope: Option<String>,
    /// no description provided
    #[serde(rename="kgForeignKey")]
    pub kg_foreign_key: Option<String>,
    /// An identifier for this district, relative to its scope. For example, the 34th State Senate district would have id "34" and a scope of stateUpper.
    pub id: Option<String>,
    /// The name of the district.
    pub name: Option<String>,
}

impl Part for ElectoralDistrict {}


/// Information about individual election officials.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ElectionOfficial {
    /// The fax number of the election official.
    #[serde(rename="faxNumber")]
    pub fax_number: Option<String>,
    /// The email address of the election official.
    #[serde(rename="emailAddress")]
    pub email_address: Option<String>,
    /// The full name of the election official.
    pub name: Option<String>,
    /// The office phone number of the election official.
    #[serde(rename="officePhoneNumber")]
    pub office_phone_number: Option<String>,
    /// The title of the election official.
    pub title: Option<String>,
}

impl Part for ElectionOfficial {}


/// Information about a candidate running for elected office.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Candidate {
    /// The candidate's name. If this is a joint ticket it will indicate the name of the candidate at the top of a ticket followed by a / and that name of candidate at the bottom of the ticket. e.g. "Mitt Romney / Paul Ryan"
    pub name: Option<String>,
    /// A URL for a photo of the candidate.
    #[serde(rename="photoUrl")]
    pub photo_url: Option<String>,
    /// The URL for the candidate's campaign web site.
    #[serde(rename="candidateUrl")]
    pub candidate_url: Option<String>,
    /// A list of known (social) media channels for this candidate.
    pub channels: Option<Vec<Channel>>,
    /// The voice phone number for the candidate's campaign office.
    pub phone: Option<String>,
    /// The order the candidate appears on the ballot for this contest.
    #[serde(rename="orderOnBallot")]
    pub order_on_ballot: Option<String>,
    /// The full name of the party the candidate is a member of.
    pub party: Option<String>,
    /// The email address for the candidate's campaign.
    pub email: Option<String>,
}

impl Part for Candidate {}


/// Information about a contest that appears on a voter's ballot.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Contest {
    /// The threshold of votes that the referendum needs in order to pass, e.g. "two-thirds". This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumPassageThreshold")]
    pub referendum_passage_threshold: Option<String>,
    /// The full text of the referendum. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumText")]
    pub referendum_text: Option<String>,
    /// The name of the office for this contest.
    pub office: Option<String>,
    /// Specifies a short summary of the referendum that is typically on the ballot below the title but above the text. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumBrief")]
    pub referendum_brief: Option<String>,
    /// A list of sources for this contest. If multiple sources are listed, the data has been aggregated from those sources.
    pub sources: Option<Vec<Source>>,
    /// If this is a partisan election, the name of the party it is for.
    #[serde(rename="primaryParty")]
    pub primary_party: Option<String>,
    /// A brief description of the referendum. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumSubtitle")]
    pub referendum_subtitle: Option<String>,
    /// A description of any additional eligibility requirements for voting in this contest.
    #[serde(rename="electorateSpecifications")]
    pub electorate_specifications: Option<String>,
    /// The roles which this office fulfills.
    pub roles: Option<Vec<String>>,
    /// The number of candidates that will be elected to office in this contest.
    #[serde(rename="numberElected")]
    pub number_elected: Option<String>,
    /// A link to the referendum. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumUrl")]
    pub referendum_url: Option<String>,
    /// The title of the referendum (e.g. 'Proposition 42'). This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumTitle")]
    pub referendum_title: Option<String>,
    /// An ID for this object. IDs may change in future requests and should not be cached. Access to this field requires special access that can be requested from the Request more link on the Quotas page.
    pub id: Option<String>,
    /// "Yes" or "No" depending on whether this a contest being held outside the normal election cycle.
    pub special: Option<String>,
    /// Specifies what effect abstaining (not voting) on the proposition will have (i.e. whether abstaining is considered a vote against it). This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumEffectOfAbstain")]
    pub referendum_effect_of_abstain: Option<String>,
    /// The number of candidates that a voter may vote for in this contest.
    #[serde(rename="numberVotingFor")]
    pub number_voting_for: Option<String>,
    /// A statement in opposition to the referendum. It does not necessarily appear on the ballot. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumConStatement")]
    pub referendum_con_statement: Option<String>,
    /// Information about the electoral district that this contest is in.
    pub district: Option<ElectoralDistrict>,
    /// The levels of government of the office for this contest. There may be more than one in cases where a jurisdiction effectively acts at two different levels of government; for example, the mayor of the District of Columbia acts at "locality" level, but also effectively at both "administrative-area-2" and "administrative-area-1".
    pub level: Option<Vec<String>>,
    /// A number specifying the position of this contest on the voter's ballot.
    #[serde(rename="ballotPlacement")]
    pub ballot_placement: Option<String>,
    /// The set of ballot responses for the referendum. A ballot response represents a line on the ballot. Common examples might include "yes" or "no" for referenda. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumBallotResponses")]
    pub referendum_ballot_responses: Option<Vec<String>>,
    /// A statement in favor of the referendum. It does not necessarily appear on the ballot. This field is only populated for contests of type 'Referendum'.
    #[serde(rename="referendumProStatement")]
    pub referendum_pro_statement: Option<String>,
    /// The candidate choices for this contest.
    pub candidates: Option<Vec<Candidate>>,
    /// The type of contest. Usually this will be 'General', 'Primary', or 'Run-off' for contests with candidates. For referenda this will be 'Referendum'. For Retention contests this will typically be 'Retention'.
    #[serde(rename="type")]
    pub type_: Option<String>,
}

impl Part for Contest {}


/// The list of elections available for this version of the API.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [election query elections](struct.ElectionElectionQueryCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ElectionsQueryResponse {
    /// Identifies what kind of resource this is. Value: the fixed string "civicinfo#electionsQueryResponse".
    pub kind: Option<String>,
    /// A list of available elections
    pub elections: Option<Vec<Election>>,
}

impl ResponseResult for ElectionsQueryResponse {}


/// The result of a representative info lookup query.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [representative info by address representatives](struct.RepresentativeRepresentativeInfoByAddresCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct RepresentativeInfoResponse {
    /// Political geographic divisions that contain the requested address.
    pub divisions: Option<HashMap<String, GeographicDivision>>,
    /// Identifies what kind of resource this is. Value: the fixed string "civicinfo#representativeInfoResponse".
    pub kind: Option<String>,
    /// Officials holding the offices listed above. Will only be present if includeOffices was true in the request.
    pub officials: Option<Vec<Official>>,
    /// Elected offices referenced by the divisions listed above. Will only be present if includeOffices was true in the request.
    pub offices: Option<Vec<Office>>,
    /// The normalized version of the requested address
    #[serde(rename="normalizedInput")]
    pub normalized_input: Option<SimpleAddressType>,
}

impl ResponseResult for RepresentativeInfoResponse {}


/// A request for information about a voter.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [voter info query elections](struct.ElectionVoterInfoQueryCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VoterInfoRequest {
    /// no description provided
    #[serde(rename="voterInfoSegmentResult")]
    pub voter_info_segment_result: Option<VoterInfoSegmentResult>,
    /// no description provided
    #[serde(rename="contextParams")]
    pub context_params: Option<ContextParams>,
}

impl RequestValue for VoterInfoRequest {}


/// Contains information about the data source for the element containing it.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Source {
    /// Whether this data comes from an official government source.
    pub official: Option<bool>,
    /// The name of the data source.
    pub name: Option<String>,
}

impl Part for Source {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ContextParams {
    /// no description provided
    #[serde(rename="clientProfile")]
    pub client_profile: Option<String>,
}

impl Part for ContextParams {}


/// The result of a division search query.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [search divisions](struct.DivisionSearchCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct DivisionSearchResponse {
    /// Identifies what kind of resource this is. Value: the fixed string "civicinfo#divisionSearchResponse".
    pub kind: Option<String>,
    /// no description provided
    pub results: Option<Vec<DivisionSearchResult>>,
}

impl ResponseResult for DivisionSearchResponse {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PostalAddress {
    /// no description provided
    #[serde(rename="languageCode")]
    pub language_code: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfareTrailingType")]
    pub dependent_thoroughfare_trailing_type: Option<String>,
    /// no description provided
    #[serde(rename="postalCodeNumber")]
    pub postal_code_number: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfaresType")]
    pub dependent_thoroughfares_type: Option<String>,
    /// no description provided
    #[serde(rename="thoroughfareTrailingType")]
    pub thoroughfare_trailing_type: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfaresIndicator")]
    pub dependent_thoroughfares_indicator: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfareLeadingType")]
    pub dependent_thoroughfare_leading_type: Option<String>,
    /// no description provided
    #[serde(rename="countryName")]
    pub country_name: Option<String>,
    /// no description provided
    #[serde(rename="premiseName")]
    pub premise_name: Option<String>,
    /// no description provided
    #[serde(rename="postalCodeNumberExtension")]
    pub postal_code_number_extension: Option<String>,
    /// no description provided
    #[serde(rename="localityName")]
    pub locality_name: Option<String>,
    /// no description provided
    #[serde(rename="thoroughfarePreDirection")]
    pub thoroughfare_pre_direction: Option<String>,
    /// no description provided
    #[serde(rename="recipientName")]
    pub recipient_name: Option<String>,
    /// no description provided
    #[serde(rename="thoroughfareNumber")]
    pub thoroughfare_number: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfarePreDirection")]
    pub dependent_thoroughfare_pre_direction: Option<String>,
    /// no description provided
    #[serde(rename="administrativeAreaName")]
    pub administrative_area_name: Option<String>,
    /// no description provided
    #[serde(rename="thoroughfareLeadingType")]
    pub thoroughfare_leading_type: Option<String>,
    /// no description provided
    #[serde(rename="firmName")]
    pub firm_name: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfarePostDirection")]
    pub dependent_thoroughfare_post_direction: Option<String>,
    /// no description provided
    #[serde(rename="countryNameCode")]
    pub country_name_code: Option<String>,
    /// no description provided
    #[serde(rename="sortingCode")]
    pub sorting_code: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfaresConnector")]
    pub dependent_thoroughfares_connector: Option<String>,
    /// no description provided
    #[serde(rename="isDisputed")]
    pub is_disputed: Option<bool>,
    /// no description provided
    #[serde(rename="subAdministrativeAreaName")]
    pub sub_administrative_area_name: Option<String>,
    /// no description provided
    #[serde(rename="thoroughfarePostDirection")]
    pub thoroughfare_post_direction: Option<String>,
    /// no description provided
    #[serde(rename="dependentLocalityName")]
    pub dependent_locality_name: Option<String>,
    /// no description provided
    #[serde(rename="dependentThoroughfareName")]
    pub dependent_thoroughfare_name: Option<String>,
    /// no description provided
    #[serde(rename="subPremiseName")]
    pub sub_premise_name: Option<String>,
    /// no description provided
    #[serde(rename="thoroughfareName")]
    pub thoroughfare_name: Option<String>,
    /// no description provided
    #[serde(rename="postBoxNumber")]
    pub post_box_number: Option<String>,
    /// no description provided
    #[serde(rename="addressLines")]
    pub address_lines: Option<Vec<String>>,
}

impl Part for PostalAddress {}


/// Information about an election administrative body (e.g. County Board of Elections).
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct AdministrativeBody {
    /// A URL provided by this administrative body for information on absentee voting.
    #[serde(rename="absenteeVotingInfoUrl")]
    pub absentee_voting_info_url: Option<String>,
    /// A URL provided by this administrative body for looking up where to vote.
    #[serde(rename="votingLocationFinderUrl")]
    pub voting_location_finder_url: Option<String>,
    /// The name of this election administrative body.
    pub name: Option<String>,
    /// A URL provided by this administrative body for confirming that the voter is registered to vote.
    #[serde(rename="electionRegistrationConfirmationUrl")]
    pub election_registration_confirmation_url: Option<String>,
    /// A URL provided by this administrative body for looking up general election information.
    #[serde(rename="electionInfoUrl")]
    pub election_info_url: Option<String>,
    /// A URL provided by this administrative body for looking up how to register to vote.
    #[serde(rename="electionRegistrationUrl")]
    pub election_registration_url: Option<String>,
    /// The election officials for this election administrative body.
    #[serde(rename="electionOfficials")]
    pub election_officials: Option<Vec<ElectionOfficial>>,
    /// The mailing address of this administrative body.
    #[serde(rename="correspondenceAddress")]
    pub correspondence_address: Option<SimpleAddressType>,
    /// no description provided
    #[serde(rename="addressLines")]
    pub address_lines: Option<Vec<String>>,
    /// A description of the services this administrative body may provide.
    pub voter_services: Option<Vec<String>>,
    /// A URL provided by this administrative body to give contest information to the voter.
    #[serde(rename="ballotInfoUrl")]
    pub ballot_info_url: Option<String>,
    /// A description of the hours of operation for this administrative body.
    #[serde(rename="hoursOfOperation")]
    pub hours_of_operation: Option<String>,
    /// The physical address of this administrative body.
    #[serde(rename="physicalAddress")]
    pub physical_address: Option<SimpleAddressType>,
    /// A URL provided by this administrative body describing election rules to the voter.
    #[serde(rename="electionRulesUrl")]
    pub election_rules_url: Option<String>,
}

impl Part for AdministrativeBody {}


/// A social media or web channel for a candidate.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Channel {
    /// The type of channel. The following is a list of types of channels, but is not exhaustive. More channel types may be added at a later time. One of: GooglePlus, YouTube, Facebook, Twitter
    #[serde(rename="type")]
    pub type_: Option<String>,
    /// The unique public identifier for the candidate's channel.
    pub id: Option<String>,
}

impl Part for Channel {}


/// There is no detailed description.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VoterInfoSegmentResult {
    /// no description provided
    #[serde(rename="postalAddress")]
    pub postal_address: Option<PostalAddress>,
    /// no description provided
    pub request: Option<VoterInfoRequest>,
    /// no description provided
    pub response: Option<VoterInfoResponse>,
    /// no description provided
    #[serde(rename="generatedMillis")]
    pub generated_millis: Option<String>,
}

impl Part for VoterInfoSegmentResult {}


/// A request for political geography and representative information for an address.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [representative info by address representatives](struct.RepresentativeRepresentativeInfoByAddresCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct RepresentativeInfoRequest {
    /// no description provided
    #[serde(rename="contextParams")]
    pub context_params: Option<ContextParams>,
}

impl RequestValue for RepresentativeInfoRequest {}


/// Information about an Office held by one or more Officials.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Office {
    /// A list of sources for this office. If multiple sources are listed, the data has been aggregated from those sources.
    pub sources: Option<Vec<Source>>,
    /// The levels of government of which this office is part. There may be more than one in cases where a jurisdiction effectively acts at two different levels of government; for example, the mayor of the District of Columbia acts at "locality" level, but also effectively at both "administrative-area-2" and "administrative-area-1".
    pub levels: Option<Vec<String>>,
    /// The human-readable name of the office.
    pub name: Option<String>,
    /// The roles which this office fulfills. Roles are not meant to be exhaustive, or to exactly specify the entire set of responsibilities of a given office, but are meant to be rough categories that are useful for general selection from or sorting of a list of offices.
    pub roles: Option<Vec<String>>,
    /// The OCD ID of the division with which this office is associated.
    #[serde(rename="divisionId")]
    pub division_id: Option<String>,
    /// List of indices in the officials array of people who presently hold this office.
    #[serde(rename="officialIndices")]
    pub official_indices: Option<Vec<u32>>,
}

impl Part for Office {}


/// A simple representation of an address.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct SimpleAddressType {
    /// The name of the location.
    #[serde(rename="locationName")]
    pub location_name: Option<String>,
    /// The city or town for the address.
    pub city: Option<String>,
    /// The US two letter state abbreviation of the address.
    pub state: Option<String>,
    /// The US Postal Zip Code of the address.
    pub zip: Option<String>,
    /// The third line of the address, if needed.
    pub line3: Option<String>,
    /// The second line the address, if needed.
    pub line2: Option<String>,
    /// The street name and number of this address.
    pub line1: Option<String>,
}

impl Part for SimpleAddressType {}


/// Represents a political geographic division that matches the requested query.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct DivisionSearchResult {
    /// The unique Open Civic Data identifier for this division.
    #[serde(rename="ocdId")]
    pub ocd_id: Option<String>,
    /// The name of the division.
    pub name: Option<String>,
    /// Other Open Civic Data identifiers that refer to the same division -- for example, those that refer to other political divisions whose boundaries are defined to be coterminous with this one. For example, ocd-division/country:us/state:wy will include an alias of ocd-division/country:us/state:wy/cd:1, since Wyoming has only one Congressional district.
    pub aliases: Option<Vec<String>>,
}

impl Part for DivisionSearchResult {}


/// A request to look up representative information for a single division.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [representative info by division representatives](struct.RepresentativeRepresentativeInfoByDivisionCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct DivisionRepresentativeInfoRequest {
    /// no description provided
    #[serde(rename="contextParams")]
    pub context_params: Option<ContextParams>,
}

impl RequestValue for DivisionRepresentativeInfoRequest {}


/// Describes a political geography.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct GeographicDivision {
    /// List of indices in the offices array, one for each office elected from this division. Will only be present if includeOffices was true (or absent) in the request.
    #[serde(rename="officeIndices")]
    pub office_indices: Option<Vec<u32>>,
    /// Any other valid OCD IDs that refer to the same division.
    /// 
    /// Because OCD IDs are meant to be human-readable and at least somewhat predictable, there are occasionally several identifiers for a single division. These identifiers are defined to be equivalent to one another, and one is always indicated as the primary identifier. The primary identifier will be returned in ocd_id above, and any other equivalent valid identifiers will be returned in this list.
    /// 
    /// For example, if this division's OCD ID is ocd-division/country:us/district:dc, this will contain ocd-division/country:us/state:dc.
    #[serde(rename="alsoKnownAs")]
    pub also_known_as: Option<Vec<String>>,
    /// The name of the division.
    pub name: Option<String>,
}

impl Part for GeographicDivision {}


/// A location where a voter can vote. This may be an early vote site, an election day voting location, or a drop off location for a completed ballot.
/// 
/// This type is not used in any activity, and only used as *part* of another schema.
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct PollingLocation {
    /// The first date that this early vote site or drop off location may be used. This field is not populated for polling locations.
    #[serde(rename="startDate")]
    pub start_date: Option<String>,
    /// A description of when this location is open.
    #[serde(rename="pollingHours")]
    pub polling_hours: Option<String>,
    /// The last date that this early vote site or drop off location may be used. This field is not populated for polling locations.
    #[serde(rename="endDate")]
    pub end_date: Option<String>,
    /// The name of the early vote site or drop off location. This field is not populated for polling locations.
    pub name: Option<String>,
    /// Notes about this location (e.g. accessibility ramp or entrance to use).
    pub notes: Option<String>,
    /// The address of the location.
    pub address: Option<SimpleAddressType>,
    /// A list of sources for this location. If multiple sources are listed the data has been aggregated from those sources.
    pub sources: Option<Vec<Source>>,
    /// The services provided by this early vote site or drop off location. This field is not populated for polling locations.
    #[serde(rename="voterServices")]
    pub voter_services: Option<String>,
    /// An ID for this object. IDs may change in future requests and should not be cached. Access to this field requires special access that can be requested from the Request more link on the Quotas page.
    pub id: Option<String>,
}

impl Part for PollingLocation {}


/// Information about the election that was queried.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [voter info query elections](struct.ElectionVoterInfoQueryCall.html) (none)
/// * [election query elections](struct.ElectionElectionQueryCall.html) (none)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Election {
    /// Day of the election in YYYY-MM-DD format.
    #[serde(rename="electionDay")]
    pub election_day: Option<String>,
    /// The unique ID of this election.
    pub id: Option<String>,
    /// A displayable name for the election.
    pub name: Option<String>,
    /// The political division of the election. Represented as an OCD Division ID. Voters within these political jurisdictions are covered by this election. This is typically a state such as ocd-division/country:us/state:ca or for the midterms or general election the entire US (i.e. ocd-division/country:us).
    #[serde(rename="ocdDivisionId")]
    pub ocd_division_id: Option<String>,
}

impl Resource for Election {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [election query elections](struct.ElectionElectionQueryCall.html) (request)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ElectionsQueryRequest {
    /// no description provided
    #[serde(rename="contextParams")]
    pub context_params: Option<ContextParams>,
}

impl RequestValue for ElectionsQueryRequest {}


/// The result of a voter info lookup query.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [voter info query elections](struct.ElectionVoterInfoQueryCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct VoterInfoResponse {
    /// Locations where the voter is eligible to vote early, prior to election day.
    #[serde(rename="earlyVoteSites")]
    pub early_vote_sites: Option<Vec<PollingLocation>>,
    /// Locations where a voter is eligible to drop off a completed ballot. The voter must have received and completed a ballot prior to arriving at the location. The location may not have ballots available on the premises. These locations could be open on or before election day as indicated in the pollingHours field.
    #[serde(rename="dropOffLocations")]
    pub drop_off_locations: Option<Vec<PollingLocation>>,
    /// If no election ID was specified in the query, and there was more than one election with data for the given voter, this will contain information about the other elections that could apply.
    #[serde(rename="otherElections")]
    pub other_elections: Option<Vec<Election>>,
    /// Specifies whether voters in the precinct vote only by mailing their ballots (with the possible option of dropping off their ballots as well).
    #[serde(rename="mailOnly")]
    pub mail_only: Option<bool>,
    /// Identifies what kind of resource this is. Value: the fixed string "civicinfo#voterInfoResponse".
    pub kind: Option<String>,
    /// The normalized version of the requested address
    #[serde(rename="normalizedInput")]
    pub normalized_input: Option<SimpleAddressType>,
    /// Local Election Information for the state that the voter votes in. For the US, there will only be one element in this array.
    pub state: Option<Vec<AdministrationRegion>>,
    /// no description provided
    #[serde(rename="precinctId")]
    pub precinct_id: Option<String>,
    /// The election that was queried.
    pub election: Option<Election>,
    /// Locations where the voter is eligible to vote on election day.
    #[serde(rename="pollingLocations")]
    pub polling_locations: Option<Vec<PollingLocation>>,
    /// Contests that will appear on the voter's ballot.
    pub contests: Option<Vec<Contest>>,
}

impl ResponseResult for VoterInfoResponse {}


/// There is no detailed description.
/// 
/// # Activities
/// 
/// This type is used in activities, which are methods you may call on this type or where this type is involved in. 
/// The list links the activity name, along with information about where it is used (one of *request* and *response*).
/// 
/// * [representative info by division representatives](struct.RepresentativeRepresentativeInfoByDivisionCall.html) (response)
/// 
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct RepresentativeInfoData {
    /// Political geographic divisions that contain the requested address.
    pub divisions: Option<HashMap<String, GeographicDivision>>,
    /// Officials holding the offices listed above. Will only be present if includeOffices was true in the request.
    pub officials: Option<Vec<Official>>,
    /// Elected offices referenced by the divisions listed above. Will only be present if includeOffices was true in the request.
    pub offices: Option<Vec<Office>>,
}

impl ResponseResult for RepresentativeInfoData {}



// ###################
// MethodBuilders ###
// #################

/// A builder providing access to all methods supported on *division* resources.
/// It is not used directly, but through the `CivicInfo` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_civicinfo2 as civicinfo2;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use civicinfo2::CivicInfo;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::new(),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `search(...)`
/// // to build up your call.
/// let rb = hub.divisions();
/// # }
/// ```
pub struct DivisionMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
}

impl<'a, C, A> MethodsBuilder for DivisionMethods<'a, C, A> {}

impl<'a, C, A> DivisionMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Searches for political divisions by their natural name or OCD ID.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn search(&self, request: DivisionSearchRequest) -> DivisionSearchCall<'a, C, A> {
        DivisionSearchCall {
            hub: self.hub,
            _request: request,
            _query: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *election* resources.
/// It is not used directly, but through the `CivicInfo` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_civicinfo2 as civicinfo2;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use civicinfo2::CivicInfo;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::new(),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `election_query(...)` and `voter_info_query(...)`
/// // to build up your call.
/// let rb = hub.elections();
/// # }
/// ```
pub struct ElectionMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
}

impl<'a, C, A> MethodsBuilder for ElectionMethods<'a, C, A> {}

impl<'a, C, A> ElectionMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// List of available elections to query.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn election_query(&self, request: ElectionsQueryRequest) -> ElectionElectionQueryCall<'a, C, A> {
        ElectionElectionQueryCall {
            hub: self.hub,
            _request: request,
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Looks up information relevant to a voter based on the voter's registered address.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `address` - The registered address of the voter to look up.
    pub fn voter_info_query(&self, request: VoterInfoRequest, address: &str) -> ElectionVoterInfoQueryCall<'a, C, A> {
        ElectionVoterInfoQueryCall {
            hub: self.hub,
            _request: request,
            _address: address.to_string(),
            _return_all_available_data: Default::default(),
            _official_only: Default::default(),
            _election_id: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
}



/// A builder providing access to all methods supported on *representative* resources.
/// It is not used directly, but through the `CivicInfo` hub.
///
/// # Example
///
/// Instantiate a resource builder
///
/// ```test_harness,no_run
/// extern crate hyper;
/// extern crate yup_oauth2 as oauth2;
/// extern crate google_civicinfo2 as civicinfo2;
/// 
/// # #[test] fn egal() {
/// use std::default::Default;
/// use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// use civicinfo2::CivicInfo;
/// 
/// let secret: ApplicationSecret = Default::default();
/// let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
///                               hyper::Client::new(),
///                               <MemoryStorage as Default>::default(), None);
/// let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // Usually you wouldn't bind this to a variable, but keep calling *CallBuilders*
/// // like `representative_info_by_address(...)` and `representative_info_by_division(...)`
/// // to build up your call.
/// let rb = hub.representatives();
/// # }
/// ```
pub struct RepresentativeMethods<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
}

impl<'a, C, A> MethodsBuilder for RepresentativeMethods<'a, C, A> {}

impl<'a, C, A> RepresentativeMethods<'a, C, A> {
    
    /// Create a builder to help you perform the following task:
    ///
    /// Looks up political geography and representative information for a single address.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    pub fn representative_info_by_address(&self, request: RepresentativeInfoRequest) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        RepresentativeRepresentativeInfoByAddresCall {
            hub: self.hub,
            _request: request,
            _roles: Default::default(),
            _levels: Default::default(),
            _include_offices: Default::default(),
            _address: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
    
    /// Create a builder to help you perform the following task:
    ///
    /// Looks up representative information for a single geographic division.
    /// 
    /// # Arguments
    ///
    /// * `request` - No description provided.
    /// * `ocdId` - The Open Civic Data division identifier of the division to look up.
    pub fn representative_info_by_division(&self, request: DivisionRepresentativeInfoRequest, ocd_id: &str) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        RepresentativeRepresentativeInfoByDivisionCall {
            hub: self.hub,
            _request: request,
            _ocd_id: ocd_id.to_string(),
            _roles: Default::default(),
            _recursive: Default::default(),
            _levels: Default::default(),
            _delegate: Default::default(),
            _additional_params: Default::default(),
        }
    }
}





// ###################
// CallBuilders   ###
// #################

/// Searches for political divisions by their natural name or OCD ID.
///
/// A builder for the *search* method supported by a *division* resource.
/// It is not used directly, but through a `DivisionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_civicinfo2 as civicinfo2;
/// use civicinfo2::DivisionSearchRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use civicinfo2::CivicInfo;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::new(),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = DivisionSearchRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.divisions().search(req)
///              .query("takimata")
///              .doit();
/// # }
/// ```
pub struct DivisionSearchCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
    _request: DivisionSearchRequest,
    _query: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for DivisionSearchCall<'a, C, A> {}

impl<'a, C, A> DivisionSearchCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, DivisionSearchResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "civicinfo.divisions.search",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity((4 + self._additional_params.len()));
        if let Some(value) = self._query {
            params.push(("query", value.to_string()));
        }
        for &field in ["alt", "query"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = "https://www.googleapis.com/civicinfo/v2/divisions".to_string();
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        if params.len() > 0 {
            url.push('?');
            url.push_str(&url::form_urlencoded::serialize(params));
        }

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request);
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, &url)
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();
                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json::from_str(&json_err).ok(),
                                                              json::from_str(&json_err).ok()) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: DivisionSearchRequest) -> DivisionSearchCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The search query. Queries can cover any parts of a OCD ID or a human readable division name. All words given in the query are treated as required patterns. In addition to that, most query operators of the Apache Lucene library are supported. See http://lucene.apache.org/core/2_9_4/queryparsersyntax.html
    ///
    /// Sets the *query* query property to the given value.
    pub fn query(mut self, new_value: &str) -> DivisionSearchCall<'a, C, A> {
        self._query = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> DivisionSearchCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known paramters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *userIp* (query-string) - IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for the response.
    pub fn param<T>(mut self, name: T, value: T) -> DivisionSearchCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// List of available elections to query.
///
/// A builder for the *electionQuery* method supported by a *election* resource.
/// It is not used directly, but through a `ElectionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_civicinfo2 as civicinfo2;
/// use civicinfo2::ElectionsQueryRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use civicinfo2::CivicInfo;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::new(),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = ElectionsQueryRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.elections().election_query(req)
///              .doit();
/// # }
/// ```
pub struct ElectionElectionQueryCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
    _request: ElectionsQueryRequest,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for ElectionElectionQueryCall<'a, C, A> {}

impl<'a, C, A> ElectionElectionQueryCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, ElectionsQueryResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "civicinfo.elections.electionQuery",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity((3 + self._additional_params.len()));
        for &field in ["alt"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = "https://www.googleapis.com/civicinfo/v2/elections".to_string();
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        if params.len() > 0 {
            url.push('?');
            url.push_str(&url::form_urlencoded::serialize(params));
        }

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request);
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, &url)
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();
                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json::from_str(&json_err).ok(),
                                                              json::from_str(&json_err).ok()) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: ElectionsQueryRequest) -> ElectionElectionQueryCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ElectionElectionQueryCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known paramters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *userIp* (query-string) - IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for the response.
    pub fn param<T>(mut self, name: T, value: T) -> ElectionElectionQueryCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Looks up information relevant to a voter based on the voter's registered address.
///
/// A builder for the *voterInfoQuery* method supported by a *election* resource.
/// It is not used directly, but through a `ElectionMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_civicinfo2 as civicinfo2;
/// use civicinfo2::VoterInfoRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use civicinfo2::CivicInfo;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::new(),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = VoterInfoRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.elections().voter_info_query(req, "address")
///              .return_all_available_data(true)
///              .official_only(false)
///              .election_id("labore")
///              .doit();
/// # }
/// ```
pub struct ElectionVoterInfoQueryCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
    _request: VoterInfoRequest,
    _address: String,
    _return_all_available_data: Option<bool>,
    _official_only: Option<bool>,
    _election_id: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for ElectionVoterInfoQueryCall<'a, C, A> {}

impl<'a, C, A> ElectionVoterInfoQueryCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, VoterInfoResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "civicinfo.elections.voterInfoQuery",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity((7 + self._additional_params.len()));
        params.push(("address", self._address.to_string()));
        if let Some(value) = self._return_all_available_data {
            params.push(("returnAllAvailableData", value.to_string()));
        }
        if let Some(value) = self._official_only {
            params.push(("officialOnly", value.to_string()));
        }
        if let Some(value) = self._election_id {
            params.push(("electionId", value.to_string()));
        }
        for &field in ["alt", "address", "returnAllAvailableData", "officialOnly", "electionId"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = "https://www.googleapis.com/civicinfo/v2/voterinfo".to_string();
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        if params.len() > 0 {
            url.push('?');
            url.push_str(&url::form_urlencoded::serialize(params));
        }

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request);
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, &url)
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();
                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json::from_str(&json_err).ok(),
                                                              json::from_str(&json_err).ok()) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: VoterInfoRequest) -> ElectionVoterInfoQueryCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The registered address of the voter to look up.
    ///
    /// Sets the *address* query property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn address(mut self, new_value: &str) -> ElectionVoterInfoQueryCall<'a, C, A> {
        self._address = new_value.to_string();
        self
    }
    /// If set to true, the query will return the success codeand include any partial information when it is unable to determine a matching address or unable to determine the election for electionId=0 queries.
    ///
    /// Sets the *return all available data* query property to the given value.
    pub fn return_all_available_data(mut self, new_value: bool) -> ElectionVoterInfoQueryCall<'a, C, A> {
        self._return_all_available_data = Some(new_value);
        self
    }
    /// If set to true, only data from official state sources will be returned.
    ///
    /// Sets the *official only* query property to the given value.
    pub fn official_only(mut self, new_value: bool) -> ElectionVoterInfoQueryCall<'a, C, A> {
        self._official_only = Some(new_value);
        self
    }
    /// The unique ID of the election to look up. A list of election IDs can be obtained at https://www.googleapis.com/civicinfo/{version}/elections
    ///
    /// Sets the *election id* query property to the given value.
    pub fn election_id(mut self, new_value: &str) -> ElectionVoterInfoQueryCall<'a, C, A> {
        self._election_id = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> ElectionVoterInfoQueryCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known paramters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *userIp* (query-string) - IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for the response.
    pub fn param<T>(mut self, name: T, value: T) -> ElectionVoterInfoQueryCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Looks up political geography and representative information for a single address.
///
/// A builder for the *representativeInfoByAddress* method supported by a *representative* resource.
/// It is not used directly, but through a `RepresentativeMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_civicinfo2 as civicinfo2;
/// use civicinfo2::RepresentativeInfoRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use civicinfo2::CivicInfo;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::new(),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = RepresentativeInfoRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.representatives().representative_info_by_address(req)
///              .add_roles("sea")
///              .add_levels("nonumy")
///              .include_offices(true)
///              .address("gubergren")
///              .doit();
/// # }
/// ```
pub struct RepresentativeRepresentativeInfoByAddresCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
    _request: RepresentativeInfoRequest,
    _roles: Vec<String>,
    _levels: Vec<String>,
    _include_offices: Option<bool>,
    _address: Option<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {}

impl<'a, C, A> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, RepresentativeInfoResponse)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "civicinfo.representatives.representativeInfoByAddress",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity((7 + self._additional_params.len()));
        if self._roles.len() > 0 {
            for f in self._roles.iter() {
                params.push(("roles", f.to_string()));
            }
        }
        if self._levels.len() > 0 {
            for f in self._levels.iter() {
                params.push(("levels", f.to_string()));
            }
        }
        if let Some(value) = self._include_offices {
            params.push(("includeOffices", value.to_string()));
        }
        if let Some(value) = self._address {
            params.push(("address", value.to_string()));
        }
        for &field in ["alt", "roles", "levels", "includeOffices", "address"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = "https://www.googleapis.com/civicinfo/v2/representatives".to_string();
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }


        if params.len() > 0 {
            url.push('?');
            url.push_str(&url::form_urlencoded::serialize(params));
        }

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request);
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, &url)
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();
                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json::from_str(&json_err).ok(),
                                                              json::from_str(&json_err).ok()) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: RepresentativeInfoRequest) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// A list of office roles to filter by. Only offices fulfilling one of these roles will be returned. Divisions that don't contain a matching office will not be returned.
    ///
    /// Append the given value to the *roles* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_roles(mut self, new_value: &str) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        self._roles.push(new_value.to_string());
        self
    }
    /// A list of office levels to filter by. Only offices that serve at least one of these levels will be returned. Divisions that don't contain a matching office will not be returned.
    ///
    /// Append the given value to the *levels* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_levels(mut self, new_value: &str) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        self._levels.push(new_value.to_string());
        self
    }
    /// Whether to return information about offices and officials. If false, only the top-level district information will be returned.
    ///
    /// Sets the *include offices* query property to the given value.
    pub fn include_offices(mut self, new_value: bool) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        self._include_offices = Some(new_value);
        self
    }
    /// The address to look up. May only be specified if the field ocdId is not given in the URL.
    ///
    /// Sets the *address* query property to the given value.
    pub fn address(mut self, new_value: &str) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        self._address = Some(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known paramters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *userIp* (query-string) - IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for the response.
    pub fn param<T>(mut self, name: T, value: T) -> RepresentativeRepresentativeInfoByAddresCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


/// Looks up representative information for a single geographic division.
///
/// A builder for the *representativeInfoByDivision* method supported by a *representative* resource.
/// It is not used directly, but through a `RepresentativeMethods` instance.
///
/// # Example
///
/// Instantiate a resource method builder
///
/// ```test_harness,no_run
/// # extern crate hyper;
/// # extern crate yup_oauth2 as oauth2;
/// # extern crate google_civicinfo2 as civicinfo2;
/// use civicinfo2::DivisionRepresentativeInfoRequest;
/// # #[test] fn egal() {
/// # use std::default::Default;
/// # use oauth2::{Authenticator, DefaultAuthenticatorDelegate, ApplicationSecret, MemoryStorage};
/// # use civicinfo2::CivicInfo;
/// 
/// # let secret: ApplicationSecret = Default::default();
/// # let auth = Authenticator::new(&secret, DefaultAuthenticatorDelegate,
/// #                               hyper::Client::new(),
/// #                               <MemoryStorage as Default>::default(), None);
/// # let mut hub = CivicInfo::new(hyper::Client::new(), auth);
/// // As the method needs a request, you would usually fill it with the desired information
/// // into the respective structure. Some of the parts shown here might not be applicable !
/// // Values shown here are possibly random and not representative !
/// let mut req = DivisionRepresentativeInfoRequest::default();
/// 
/// // You can configure optional parameters by calling the respective setters at will, and
/// // execute the final call using `doit()`.
/// // Values shown here are possibly random and not representative !
/// let result = hub.representatives().representative_info_by_division(req, "ocdId")
///              .add_roles("aliquyam")
///              .recursive(false)
///              .add_levels("no")
///              .doit();
/// # }
/// ```
pub struct RepresentativeRepresentativeInfoByDivisionCall<'a, C, A>
    where C: 'a, A: 'a {

    hub: &'a CivicInfo<C, A>,
    _request: DivisionRepresentativeInfoRequest,
    _ocd_id: String,
    _roles: Vec<String>,
    _recursive: Option<bool>,
    _levels: Vec<String>,
    _delegate: Option<&'a mut Delegate>,
    _additional_params: HashMap<String, String>,
}

impl<'a, C, A> CallBuilder for RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {}

impl<'a, C, A> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> where C: BorrowMut<hyper::Client>, A: oauth2::GetToken {


    /// Perform the operation you have build so far.
    pub fn doit(mut self) -> Result<(hyper::client::Response, RepresentativeInfoData)> {
        use std::io::{Read, Seek};
        use hyper::header::{ContentType, ContentLength, Authorization, Bearer, UserAgent, Location};
        let mut dd = DefaultDelegate;
        let mut dlg: &mut Delegate = match self._delegate {
            Some(d) => d,
            None => &mut dd
        };
        dlg.begin(MethodInfo { id: "civicinfo.representatives.representativeInfoByDivision",
                               http_method: hyper::method::Method::Get });
        let mut params: Vec<(&str, String)> = Vec::with_capacity((7 + self._additional_params.len()));
        params.push(("ocdId", self._ocd_id.to_string()));
        if self._roles.len() > 0 {
            for f in self._roles.iter() {
                params.push(("roles", f.to_string()));
            }
        }
        if let Some(value) = self._recursive {
            params.push(("recursive", value.to_string()));
        }
        if self._levels.len() > 0 {
            for f in self._levels.iter() {
                params.push(("levels", f.to_string()));
            }
        }
        for &field in ["alt", "ocdId", "roles", "recursive", "levels"].iter() {
            if self._additional_params.contains_key(field) {
                dlg.finished(false);
                return Err(Error::FieldClash(field));
            }
        }
        for (name, value) in self._additional_params.iter() {
            params.push((&name, value.clone()));
        }

        params.push(("alt", "json".to_string()));

        let mut url = "https://www.googleapis.com/civicinfo/v2/representatives/{ocdId}".to_string();
        
        let mut key = self.hub.auth.borrow_mut().api_key();
        if key.is_none() {
            key = dlg.api_key();
        }
        match key {
            Some(value) => params.push(("key", value)),
            None => {
                dlg.finished(false);
                return Err(Error::MissingAPIKey)
            }
        }

        for &(find_this, param_name) in [("{ocdId}", "ocdId")].iter() {
            let mut replace_with: Option<&str> = None;
            for &(name, ref value) in params.iter() {
                if name == param_name {
                    replace_with = Some(value);
                    break;
                }
            }
            url = url.replace(find_this, replace_with.expect("to find substitution value in params"));
        }
        {
            let mut indices_for_removal: Vec<usize> = Vec::with_capacity(1);
            for param_name in ["ocdId"].iter() {
                if let Some(index) = params.iter().position(|t| &t.0 == param_name) {
                    indices_for_removal.push(index);
                }
            }
            for &index in indices_for_removal.iter() {
                params.remove(index);
            }
        }

        if params.len() > 0 {
            url.push('?');
            url.push_str(&url::form_urlencoded::serialize(params));
        }

        let mut json_mime_type = mime::Mime(mime::TopLevel::Application, mime::SubLevel::Json, Default::default());
        let mut request_value_reader =
            {
                let mut value = json::value::to_value(&self._request);
                remove_json_null_values(&mut value);
                let mut dst = io::Cursor::new(Vec::with_capacity(128));
                json::to_writer(&mut dst, &value).unwrap();
                dst
            };
        let request_size = request_value_reader.seek(io::SeekFrom::End(0)).unwrap();
        request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();


        loop {
            request_value_reader.seek(io::SeekFrom::Start(0)).unwrap();
            let mut req_result = {
                let mut client = &mut *self.hub.client.borrow_mut();
                let mut req = client.borrow_mut().request(hyper::method::Method::Get, &url)
                    .header(UserAgent(self.hub._user_agent.clone()))
                    .header(ContentType(json_mime_type.clone()))
                    .header(ContentLength(request_size as u64))
                    .body(&mut request_value_reader);

                dlg.pre_request();
                req.send()
            };

            match req_result {
                Err(err) => {
                    if let oauth2::Retry::After(d) = dlg.http_error(&err) {
                        sleep(d);
                        continue;
                    }
                    dlg.finished(false);
                    return Err(Error::HttpError(err))
                }
                Ok(mut res) => {
                    if !res.status.is_success() {
                        let mut json_err = String::new();
                        res.read_to_string(&mut json_err).unwrap();
                        if let oauth2::Retry::After(d) = dlg.http_failure(&res,
                                                              json::from_str(&json_err).ok(),
                                                              json::from_str(&json_err).ok()) {
                            sleep(d);
                            continue;
                        }
                        dlg.finished(false);
                        return match json::from_str::<ErrorResponse>(&json_err){
                            Err(_) => Err(Error::Failure(res)),
                            Ok(serr) => Err(Error::BadRequest(serr))
                        }
                    }
                    let result_value = {
                        let mut json_response = String::new();
                        res.read_to_string(&mut json_response).unwrap();
                        match json::from_str(&json_response) {
                            Ok(decoded) => (res, decoded),
                            Err(err) => {
                                dlg.response_json_decode_error(&json_response, &err);
                                return Err(Error::JsonDecodeError(json_response, err));
                            }
                        }
                    };

                    dlg.finished(true);
                    return Ok(result_value)
                }
            }
        }
    }


    ///
    /// Sets the *request* property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn request(mut self, new_value: DivisionRepresentativeInfoRequest) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        self._request = new_value;
        self
    }
    /// The Open Civic Data division identifier of the division to look up.
    ///
    /// Sets the *ocd id* path property to the given value.
    ///
    /// Even though the property as already been set when instantiating this call,
    /// we provide this method for API completeness.
    pub fn ocd_id(mut self, new_value: &str) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        self._ocd_id = new_value.to_string();
        self
    }
    /// A list of office roles to filter by. Only offices fulfilling one of these roles will be returned. Divisions that don't contain a matching office will not be returned.
    ///
    /// Append the given value to the *roles* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_roles(mut self, new_value: &str) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        self._roles.push(new_value.to_string());
        self
    }
    /// If true, information about all divisions contained in the division requested will be included as well. For example, if querying ocd-division/country:us/district:dc, this would also return all DC's wards and ANCs.
    ///
    /// Sets the *recursive* query property to the given value.
    pub fn recursive(mut self, new_value: bool) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        self._recursive = Some(new_value);
        self
    }
    /// A list of office levels to filter by. Only offices that serve at least one of these levels will be returned. Divisions that don't contain a matching office will not be returned.
    ///
    /// Append the given value to the *levels* query property.
    /// Each appended value will retain its original ordering and be '/'-separated in the URL's parameters.
    pub fn add_levels(mut self, new_value: &str) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        self._levels.push(new_value.to_string());
        self
    }
    /// The delegate implementation is consulted whenever there is an intermediate result, or if something goes wrong
    /// while executing the actual API request.
    /// 
    /// It should be used to handle progress information, and to implement a certain level of resilience.
    ///
    /// Sets the *delegate* property to the given value.
    pub fn delegate(mut self, new_value: &'a mut Delegate) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A> {
        self._delegate = Some(new_value);
        self
    }

    /// Set any additional parameter of the query string used in the request.
    /// It should be used to set parameters which are not yet available through their own
    /// setters.
    ///
    /// Please note that this method must not be used to set any of the known paramters
    /// which have their own setter method. If done anyway, the request will fail.
    ///
    /// # Additional Parameters
    ///
    /// * *quotaUser* (query-string) - Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. Overrides userIp if both are provided.
    /// * *oauth_token* (query-string) - OAuth 2.0 token for the current user.
    /// * *key* (query-string) - API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    /// * *prettyPrint* (query-boolean) - Returns response with indentations and line breaks.
    /// * *userIp* (query-string) - IP address of the site where the request originates. Use this if you want to enforce per-user limits.
    /// * *fields* (query-string) - Selector specifying which fields to include in a partial response.
    /// * *alt* (query-string) - Data format for the response.
    pub fn param<T>(mut self, name: T, value: T) -> RepresentativeRepresentativeInfoByDivisionCall<'a, C, A>
                                                        where T: AsRef<str> {
        self._additional_params.insert(name.as_ref().to_string(), value.as_ref().to_string());
        self
    }

}


